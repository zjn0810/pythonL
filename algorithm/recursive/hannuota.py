#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Jun  6 09:02:21 2021

@author: zhangjn
"""

# =============================================================================
# 汉诺塔问题:递归思路
# ❖ 将盘片塔从开始柱,经由中间柱,移动到目标柱:
# 首先将上层N-1个盘片的盘片塔,从开始柱,经由目标柱,移动到中间柱;
# 然后将第N个(最大的)盘片,从开始柱,移动到目标柱;
# 最后将放置在中间柱的N-1个盘片的盘片塔,经由开始柱,移动到目标柱。
# ❖ 基本结束条件,也就是最小规模问题是:
# 1个盘片的移动问题
# =============================================================================
# =============================================================================
# my思考：所谓经由，即非目标柱。从递归思路理解
# =============================================================================
def moveTower(height, fromPole, withPole, toPole):
    if height >= 1:
        moveTower(height - 1, fromPole, toPole, withPole)
        moveDisk(height, fromPole, toPole)
        moveTower(height - 1, withPole, fromPole, toPole)

def moveDisk(disk, fromPole, toPole):
    print(f"Moving disk[{disk}] from {fromPole} to {toPole}")
    global count 
    count = count + 1

count = 0
moveTower(4, '#1', '#2', '#3')
print(count)


# =============================================================================
# 汉诺塔算法介绍
# 其实算法非常简单，当盘子的个数为n时，移动的次数应等于2^n – 1
# 有兴趣的可以自己证明试试看）。后来一位美国学者发现一种出人意料
# 的简单方法，只要轮流进行两步操作就可以了。首先把三根柱子按顺序排成品字型，
# 把所有的圆盘按从大到小的顺序放在柱子A上，根据圆盘的数量确定柱子的排放顺序：若n为偶数，
# 按顺时针方向依次摆放 A B C；
# 若n为奇数，按顺时针方向依次摆放 A C B。
# ⑴按顺时针方向把圆盘1从现在的柱子移动到下一根柱子，即当n为偶数时，若圆盘1在柱子A，
# 则把它移动到B；若圆盘1在柱子B，则把它移动到C；若圆盘1在柱子C，则把它移动到A。
# ⑵接着，把另外两根柱子上可以移动的圆盘移动到新的柱子上。即把非空柱子上的圆盘
# 移动到空柱子上，当两根柱子都非空时，移动较小的圆盘。这一步没有明确规定移动哪个圆盘，
# 你可能以为会有多种可能性，其实不然，可实施的行动是唯一的。
# ⑶反复进行⑴⑵操作，最后就能按规定完成汉诺塔的移动。
# 所以结果非常简单，就是按照移动规则向一个方向移动金片：
# 如3阶汉诺塔的移动：A→C,A→B,C→B,A→C,B→A,B→C,A→C
# =============================================================================
#----------------汉诺塔-----------------#
# 如果有n个圆盘,所需移动的步数为 2^n-1
# =============================================================================
# i = 0
# # 定义一个函数给4个参数n是圆盘的个数,a代表A柱子,b,c 函数里面的是形式参数
# def move(n,a,b,c):
#     # 把变量i全局化,如果不全局化,只可访问读取不能进行操作修改
#     global i
#     if n==1:
#         i += 1
#         print('移动第',i,'次',a,'-->',c)
#     else:
#         # 1.把A柱上n-1个圆盘移动到B柱上
#         move(n-1,a,c,b) # 传的才是实际参数
#         # 2.把A柱上最大的移动到C柱子上
#         move(1,a,b,c)
#         # 3.把B柱子上n-1个圆盘移动到C柱子上
#         move(n-1,b,a,c)
# 
#         
# move(4,'A','B','C')
# =============================================================================
