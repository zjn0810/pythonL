#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sun Jun  6 09:02:21 2021

@author: zhangjn
"""

# =============================================================================
# 汉诺塔问题:递归思路
# ❖ 将盘片塔从开始柱,经由中间柱,移动到目标柱:
# 首先将上层N-1个盘片的盘片塔,从开始柱,经由目标柱,移动到中间柱;
# 然后将第N个(最大的)盘片,从开始柱,移动到目标柱;
# 最后将放置在中间柱的N-1个盘片的盘片塔,经由开始柱,移动到目标柱。
# ❖ 基本结束条件,也就是最小规模问题是:
# 1个盘片的移动问题
# =============================================================================
# =============================================================================
# my思考：所谓经由，即非目标柱。从递归思路理解
# =============================================================================
def moveTower(height, fromPole, withPole, toPole):
    if height >= 1:
        moveTower(height - 1, fromPole, toPole, withPole)
        moveDisk(height, fromPole, toPole)
        moveTower(height - 1, withPole, fromPole, toPole)

def moveDisk(disk, fromPole, toPole):
    print(f"Moving disk[{disk}] from {fromPole} to {toPole}")
    global count 
    count = count + 1

count = 0
moveTower(4, '#1', '#2', '#3')
print(count)


# =============================================================================
#   因为Move这个方法就是要把盘子从 a  移动到 c，所以我们在递归调用时仅仅记住这个函数的这个功能就行了，这是一个函数的整体功能。
#   我们分别来讲解当N>1的3个步骤：
# 
#   第一步，讲 n-1 个盘子从 a 移动到 b 。把n-1盘子全部移动到 b 位置和 c 的方法是一样的，也就是算法是一样的。只是规模比原来少1。所以我们可以递归调用Move方法来解决将 n-1 个盘子从 a 移动到 b。 这时 b 就像相当于原来的c位置了,那么就这样调用   Move(n-1, a, c, b).
#   第二步，当 n-1 个盘子从 a 移动到 b 之后，a  上就一个盘子，我们就可以直接将盘子移动到 c 上面。调用MoveTo(a, c)实现盘子的移动。在这一步，其实就是相当于移动只有一个盘子的情况，我们还可以递归调算法本身 Move(1, a, b, c);  这样调用也是可以的。在执行完成后，a 位置上是空的， b 位置上有 n-1 个盘子， c 位置上有一个最大的盘子。
#   第三步，在第二步之后，我们只需要将 b 位置上的盘子都移动到 c 位置就可以了。这个和第一步类似，只是位置变了。 b 相当于原来的 a 位置（因为盘子在b上）， a 位置相当于原来的 b 位置，因为移动到 c ，所以 c 还是相当于与原来的 c 位置。 语句调用这样写 Move(n - 1, b, a, c);
#   完善MoveTo方法，输出结果就好了。如果是图形移动，在这里写移动图形的方法即可。
# 
# =============================================================================
